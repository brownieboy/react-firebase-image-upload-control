/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["rfiu"] = factory(require("react"));
	else
		root["rfiu"] = factory(root["react"]);
})(global, (__WEBPACK_EXTERNAL_MODULE_react__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/FirebaseUploader.tsx":
/*!**********************************!*\
  !*** ./src/FirebaseUploader.tsx ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* eslint-disable indent */\nconst react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nconst styles = {\n    imagePreview: {\n        maxHeight: 150,\n        maxWidth: 200\n    },\n    imagePreviewTitle: {},\n    progressControl: {\n        label: {\n            fontSize: 10\n        }\n    }\n};\nconst PlainProgressIndicator = ({ value, fileName }) => {\n    return (react_1.default.createElement(\"div\", { style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            alignItems: \"center\",\n            marginRight: 5\n        } },\n        react_1.default.createElement(\"div\", null,\n            value,\n            \"%\"),\n        react_1.default.createElement(\"div\", { style: styles.progressControl.label }, fileName)));\n};\nconst PlainCheckbox = (props) => react_1.default.createElement(\"input\", Object.assign({ type: \"checkbox\" }, props));\nconst PlainButton = (_a) => {\n    var { children } = _a, props = __rest(_a, [\"children\"]);\n    return react_1.default.createElement(\"button\", Object.assign({}, props), children);\n};\nconst PassedPropProgressIndicator = ({ component: Component, value, componentWrapperStyles, fileName }) => {\n    if (componentWrapperStyles) {\n        return (react_1.default.createElement(\"div\", { style: {\n                display: \"flex\",\n                alignItems: \"center\",\n                flexDirection: \"column\",\n                marginRight: 10\n            } },\n            react_1.default.createElement(\"div\", { style: componentWrapperStyles },\n                react_1.default.createElement(Component, { value: value })),\n            react_1.default.createElement(\"div\", { style: styles.progressControl.label }, fileName)));\n    }\n    return (react_1.default.createElement(Component, { value: value }));\n};\nconst FirebaseUploadImage = () => {\n    // const [testVal] = useState(\"hey 4\");\n    const testVal = 4;\n    console.log(\"TCL ~ file: FirebaseUploader.tsx ~ line 173 ~ FirebaseUploadImage ~ testVal\", testVal);\n    return react_1.default.createElement(\"div\", null, \"Hello FirebaseUploadImage\");\n};\n// const FirebaseUploadImage = ({\n//   firebaseApp,\n//   storageFolder = \"rfiu\",\n//   disabled = false,\n//   multiple = false,\n//   options = {\n//     styles: {\n//       imgPreview: {},\n//       imgPreviewLabel: {},\n//       progressControlWrapper: {}\n//     }\n//   },\n//   progressControl,\n//   checkboxControl,\n//   buttonControl,\n//   uploadButtonIcon,\n//   removeButtonIcon,\n//   uploadStartCallback,\n//   uploadCompleteCallback\n// }: FirebaseUploadImageProps) => {\n//   const [filesToStore, setFilesToStore] = useState<FileWithPreview[]>([]);\n//   const [filesToRemove, setFilesToRemove] = useState<string[]>([]);\n//   const [uploadState, setUploadState] = useState<FileUploadState>({});\n//   const [uploadButtonClicked, setUploadButtonClicked] = useState(false);\n//   const UploadButtonIcon = uploadButtonIcon;\n//   const RemoveButtonIcon = removeButtonIcon;\n//   const ProgressControl = progressControl\n//     ? PassedPropProgressIndicator\n//     : PlainProgressIndicator;\n//   const CheckboxControl = checkboxControl || PlainCheckbox;\n//   const ButtonControl = buttonControl || PlainButton;\n//   const storage = getStorage(firebaseApp);\n//   const handleImageChange = (acceptedFilesArray: FileWithPreview[]) => {\n//     if (multiple) {\n//       const uniqueFilesArray = _uniqBy(\n//         e => e.name,\n//         [...filesToStore, ...acceptedFilesArray]\n//       ).map(file =>\n//         // Spread operator didn't work here.  Has to be Object.assign()\n//         Object.assign(file, {\n//           preview: URL.createObjectURL(file)\n//         })\n//       );\n//       setFilesToStore(uniqueFilesArray);\n//     } else {\n//       setFilesToStore(\n//         acceptedFilesArray.map(file =>\n//           Object.assign(file, {\n//             preview: URL.createObjectURL(file)\n//           })\n//         )\n//       );\n//     }\n//     setFilesToRemove([]); // Important to clear this if we have new files\n//   };\n//   const handleProgress = (percent: number, fileName: string) => {\n//     setUploadState((prevState: any) => {\n//       return {\n//         ...prevState,\n//         [fileName]: percent\n//       };\n//     });\n//   };\n//   const startUpload = async () => {\n//     if (uploadStartCallback) {\n//       uploadStartCallback(filesToStore);\n//     }\n//     setUploadButtonClicked(true);\n//     filesToStore.forEach(file => {\n//       const storageRef = fbRef(storage, `${storageFolder}/${file.name}`);\n//       const uploadTask = uploadBytesResumable(storageRef, file);\n//       uploadTask.on(\n//         \"state_changed\",\n//         snapshot => {\n//           const progress = Math.round(\n//             (snapshot.bytesTransferred / snapshot.totalBytes) * 100\n//           );\n//           const fileName = snapshot.ref.name;\n//           handleProgress(progress, fileName);\n//         },\n//         error => {\n//           alert(error);\n//         },\n//         async () => {\n//           const downloadUrl = await getDownloadURL(uploadTask.snapshot.ref);\n//           const fileName = uploadTask?.snapshot?.ref?.name;\n//           handleUploadSuccess(fileName, downloadUrl);\n//         }\n//       );\n//     });\n//   };\n//   const handleUploadSuccess = async (fileName: string, downloadUrl: string) => {\n//     setFilesToStore(prevState => {\n//       const currentFileIndex = prevState.findIndex(\n//         member => member.name === fileName\n//       );\n//       const newFileInfo = Object.assign(prevState[currentFileIndex]);\n//       newFileInfo.downloadUrl = downloadUrl;\n//       const newState = [\n//         ...prevState.slice(0, currentFileIndex),\n//         newFileInfo,\n//         ...prevState.slice(currentFileIndex + 1)\n//       ];\n//       if (uploadCompleteCallback) {\n//         const filesWithDownloadUrls = newState.filter(\n//           member => member.downloadUrl\n//         );\n//         if (newState.length === filesWithDownloadUrls.length) {\n//           uploadCompleteCallback({files: newState});\n//         }\n//       }\n//       return newState;\n//     });\n//   };\n//   // event prop defined as any because it might be an @mui checkbox or any other\n//   // kind of checkbox, not just an HTML one.\n//   const handleFileRemovalCheck = (event: any) => {\n//     if (event.target.checked) {\n//       setFilesToRemove([...filesToRemove, event?.target?.value]);\n//     } else {\n//       setFilesToRemove(\n//         filesToRemove.filter(member => member !== event.target.value)\n//       );\n//     }\n//   };\n//   const handleRemoveFiles = () => {\n//     setFilesToStore(\n//       filesToStore.filter(member => !filesToRemove.includes(member.name))\n//     );\n//     setFilesToRemove([]); // Important to clear this after\n//   };\n//   const imgPreviewStyles = {\n//     ...styles.imagePreview,\n//     ...options?.styles?.imgPreview\n//   };\n//   const imgPreviewTitleStyles = {\n//     ...styles.imagePreviewTitle,\n//     ...options?.styles?.imgPreviewTitle\n//   };\n//   return (\n//     <>\n//       <ImageDrop onDrop={handleImageChange} multiple={multiple} />\n//       <div\n//         style={{\n//           display: \"flex\",\n//           flexWrap: \"wrap\"\n//         }}>\n//         {filesToStore.length > 0\n//           ? filesToStore.map(file => (\n//               <div\n//                 key={file.name}\n//                 style={{\n//                   display: \"flex\",\n//                   flexDirection: \"column\",\n//                   justifyContent: \"space-between\",\n//                   marginBottom: 10,\n//                   marginRight: 10\n//                 }}>\n//                 <img\n//                   src={file.preview}\n//                   title={file.name}\n//                   alt={file.name}\n//                   style={imgPreviewStyles}\n//                 />\n//                 <div style={imgPreviewTitleStyles}>\n//                   <label\n//                     htmlFor={file.name}\n//                     style={options?.styles?.imgPreviewLabel}>\n//                     {`${file.name} (${prettyBytes(file.size)})`}\n//                   </label>\n//                   <CheckboxControl\n//                     checked={filesToRemove.includes(file.name)}\n//                     onChange={handleFileRemovalCheck}\n//                     id={file.name}\n//                     value={file.name}\n//                   />\n//                 </div>\n//               </div>\n//             ))\n//           : null}\n//       </div>\n//       <div style={{display: \"flex\", alignItems: \"center\"}}>\n//         <ButtonControl\n//           variant=\"contained\"\n//           onClick={handleRemoveFiles}\n//           style={{textTransform: \"none\", marginTop: 10, marginRight: 10}}\n//           disabled={filesToRemove.length === 0}>\n//           {/* <DeleteIcon style={{ marginRight: 10 }} /> */}\n//           {removeButtonIcon ? (\n//             <RemoveButtonIcon style={{marginRight: 10}} />\n//           ) : null}\n//           Remove checked files\n//         </ButtonControl>\n//         <ButtonControl\n//           color=\"primary\"\n//           variant=\"contained\"\n//           onClick={startUpload}\n//           style={{textTransform: \"none\", marginTop: 10, marginRight: 10}}\n//           disabled={disabled || filesToStore.length === 0}>\n//           {/* <CloudUploadIcon style={{ marginRight: 10 }} /> */}\n//           {uploadButtonIcon ? (\n//             <UploadButtonIcon style={{marginRight: 10}} />\n//           ) : null}\n//           {filesToStore.length > 1 ? \"Upload all\" : \"Upload\"}\n//         </ButtonControl>\n//       </div>\n//       <div style={{display: \"flex\", alignItems: \"center\", marginTop: 10}}>\n//         {/* {uploadButtonClicked && ( */}\n//         {uploadButtonClicked &&\n//           filesToStore.map(file => {\n//             return (\n//               <ProgressControl\n//                 value={uploadState[file.name] || 0}\n//                 key={file.name}\n//                 component={progressControl}\n//                 componentWrapperStyles={options?.styles?.progressControlWrapper}\n//                 fileName={file.name}\n//               />\n//             );\n//           })}\n//       </div>\n//     </>\n//   );\n// };\nexports[\"default\"] = FirebaseUploadImage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUNBQXVDO0FBQzdEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLHVCQUF1QiwyQkFBMkI7QUFDbEQsY0FBYyx3QkFBd0IsbUJBQW1CO0FBQ3pELGNBQWM7QUFDZCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsdUJBQXVCLHNDQUFzQztBQUM3RCxjQUFjLDZCQUE2QixtQkFBbUI7QUFDOUQsY0FBYztBQUNkLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHNCQUFzQixzREFBc0Q7QUFDNUUsWUFBWSxJQUFJO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLDhCQUE4QjtBQUM5QiwyQ0FBMkM7QUFDM0MsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3JmaXUvLi9zcmMvRmlyZWJhc2VVcGxvYWRlci50c3g/MGU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuY29uc3QgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3Qgc3R5bGVzID0ge1xuICAgIGltYWdlUHJldmlldzoge1xuICAgICAgICBtYXhIZWlnaHQ6IDE1MCxcbiAgICAgICAgbWF4V2lkdGg6IDIwMFxuICAgIH0sXG4gICAgaW1hZ2VQcmV2aWV3VGl0bGU6IHt9LFxuICAgIHByb2dyZXNzQ29udHJvbDoge1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZm9udFNpemU6IDEwXG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgUGxhaW5Qcm9ncmVzc0luZGljYXRvciA9ICh7IHZhbHVlLCBmaWxlTmFtZSB9KSA9PiB7XG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IDVcbiAgICAgICAgfSB9LFxuICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBcIiVcIiksXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHN0eWxlcy5wcm9ncmVzc0NvbnRyb2wubGFiZWwgfSwgZmlsZU5hbWUpKSk7XG59O1xuY29uc3QgUGxhaW5DaGVja2JveCA9IChwcm9wcykgPT4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBPYmplY3QuYXNzaWduKHsgdHlwZTogXCJjaGVja2JveFwiIH0sIHByb3BzKSk7XG5jb25zdCBQbGFpbkJ1dHRvbiA9IChfYSkgPT4ge1xuICAgIHZhciB7IGNoaWxkcmVuIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCJdKTtcbiAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCBjaGlsZHJlbik7XG59O1xuY29uc3QgUGFzc2VkUHJvcFByb2dyZXNzSW5kaWNhdG9yID0gKHsgY29tcG9uZW50OiBDb21wb25lbnQsIHZhbHVlLCBjb21wb25lbnRXcmFwcGVyU3R5bGVzLCBmaWxlTmFtZSB9KSA9PiB7XG4gICAgaWYgKGNvbXBvbmVudFdyYXBwZXJTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAxMFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogY29tcG9uZW50V3JhcHBlclN0eWxlcyB9LFxuICAgICAgICAgICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgeyB2YWx1ZTogdmFsdWUgfSkpLFxuICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogc3R5bGVzLnByb2dyZXNzQ29udHJvbC5sYWJlbCB9LCBmaWxlTmFtZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHsgdmFsdWU6IHZhbHVlIH0pKTtcbn07XG5jb25zdCBGaXJlYmFzZVVwbG9hZEltYWdlID0gKCkgPT4ge1xuICAgIC8vIGNvbnN0IFt0ZXN0VmFsXSA9IHVzZVN0YXRlKFwiaGV5IDRcIik7XG4gICAgY29uc3QgdGVzdFZhbCA9IDQ7XG4gICAgY29uc29sZS5sb2coXCJUQ0wgfiBmaWxlOiBGaXJlYmFzZVVwbG9hZGVyLnRzeCB+IGxpbmUgMTczIH4gRmlyZWJhc2VVcGxvYWRJbWFnZSB+IHRlc3RWYWxcIiwgdGVzdFZhbCk7XG4gICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFwiSGVsbG8gRmlyZWJhc2VVcGxvYWRJbWFnZVwiKTtcbn07XG4vLyBjb25zdCBGaXJlYmFzZVVwbG9hZEltYWdlID0gKHtcbi8vICAgZmlyZWJhc2VBcHAsXG4vLyAgIHN0b3JhZ2VGb2xkZXIgPSBcInJmaXVcIixcbi8vICAgZGlzYWJsZWQgPSBmYWxzZSxcbi8vICAgbXVsdGlwbGUgPSBmYWxzZSxcbi8vICAgb3B0aW9ucyA9IHtcbi8vICAgICBzdHlsZXM6IHtcbi8vICAgICAgIGltZ1ByZXZpZXc6IHt9LFxuLy8gICAgICAgaW1nUHJldmlld0xhYmVsOiB7fSxcbi8vICAgICAgIHByb2dyZXNzQ29udHJvbFdyYXBwZXI6IHt9XG4vLyAgICAgfVxuLy8gICB9LFxuLy8gICBwcm9ncmVzc0NvbnRyb2wsXG4vLyAgIGNoZWNrYm94Q29udHJvbCxcbi8vICAgYnV0dG9uQ29udHJvbCxcbi8vICAgdXBsb2FkQnV0dG9uSWNvbixcbi8vICAgcmVtb3ZlQnV0dG9uSWNvbixcbi8vICAgdXBsb2FkU3RhcnRDYWxsYmFjayxcbi8vICAgdXBsb2FkQ29tcGxldGVDYWxsYmFja1xuLy8gfTogRmlyZWJhc2VVcGxvYWRJbWFnZVByb3BzKSA9PiB7XG4vLyAgIGNvbnN0IFtmaWxlc1RvU3RvcmUsIHNldEZpbGVzVG9TdG9yZV0gPSB1c2VTdGF0ZTxGaWxlV2l0aFByZXZpZXdbXT4oW10pO1xuLy8gICBjb25zdCBbZmlsZXNUb1JlbW92ZSwgc2V0RmlsZXNUb1JlbW92ZV0gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuLy8gICBjb25zdCBbdXBsb2FkU3RhdGUsIHNldFVwbG9hZFN0YXRlXSA9IHVzZVN0YXRlPEZpbGVVcGxvYWRTdGF0ZT4oe30pO1xuLy8gICBjb25zdCBbdXBsb2FkQnV0dG9uQ2xpY2tlZCwgc2V0VXBsb2FkQnV0dG9uQ2xpY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4vLyAgIGNvbnN0IFVwbG9hZEJ1dHRvbkljb24gPSB1cGxvYWRCdXR0b25JY29uO1xuLy8gICBjb25zdCBSZW1vdmVCdXR0b25JY29uID0gcmVtb3ZlQnV0dG9uSWNvbjtcbi8vICAgY29uc3QgUHJvZ3Jlc3NDb250cm9sID0gcHJvZ3Jlc3NDb250cm9sXG4vLyAgICAgPyBQYXNzZWRQcm9wUHJvZ3Jlc3NJbmRpY2F0b3Jcbi8vICAgICA6IFBsYWluUHJvZ3Jlc3NJbmRpY2F0b3I7XG4vLyAgIGNvbnN0IENoZWNrYm94Q29udHJvbCA9IGNoZWNrYm94Q29udHJvbCB8fCBQbGFpbkNoZWNrYm94O1xuLy8gICBjb25zdCBCdXR0b25Db250cm9sID0gYnV0dG9uQ29udHJvbCB8fCBQbGFpbkJ1dHRvbjtcbi8vICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoZmlyZWJhc2VBcHApO1xuLy8gICBjb25zdCBoYW5kbGVJbWFnZUNoYW5nZSA9IChhY2NlcHRlZEZpbGVzQXJyYXk6IEZpbGVXaXRoUHJldmlld1tdKSA9PiB7XG4vLyAgICAgaWYgKG11bHRpcGxlKSB7XG4vLyAgICAgICBjb25zdCB1bmlxdWVGaWxlc0FycmF5ID0gX3VuaXFCeShcbi8vICAgICAgICAgZSA9PiBlLm5hbWUsXG4vLyAgICAgICAgIFsuLi5maWxlc1RvU3RvcmUsIC4uLmFjY2VwdGVkRmlsZXNBcnJheV1cbi8vICAgICAgICkubWFwKGZpbGUgPT5cbi8vICAgICAgICAgLy8gU3ByZWFkIG9wZXJhdG9yIGRpZG4ndCB3b3JrIGhlcmUuICBIYXMgdG8gYmUgT2JqZWN0LmFzc2lnbigpXG4vLyAgICAgICAgIE9iamVjdC5hc3NpZ24oZmlsZSwge1xuLy8gICAgICAgICAgIHByZXZpZXc6IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSlcbi8vICAgICAgICAgfSlcbi8vICAgICAgICk7XG4vLyAgICAgICBzZXRGaWxlc1RvU3RvcmUodW5pcXVlRmlsZXNBcnJheSk7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIHNldEZpbGVzVG9TdG9yZShcbi8vICAgICAgICAgYWNjZXB0ZWRGaWxlc0FycmF5Lm1hcChmaWxlID0+XG4vLyAgICAgICAgICAgT2JqZWN0LmFzc2lnbihmaWxlLCB7XG4vLyAgICAgICAgICAgICBwcmV2aWV3OiBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpXG4vLyAgICAgICAgICAgfSlcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICB9XG4vLyAgICAgc2V0RmlsZXNUb1JlbW92ZShbXSk7IC8vIEltcG9ydGFudCB0byBjbGVhciB0aGlzIGlmIHdlIGhhdmUgbmV3IGZpbGVzXG4vLyAgIH07XG4vLyAgIGNvbnN0IGhhbmRsZVByb2dyZXNzID0gKHBlcmNlbnQ6IG51bWJlciwgZmlsZU5hbWU6IHN0cmluZykgPT4ge1xuLy8gICAgIHNldFVwbG9hZFN0YXRlKChwcmV2U3RhdGU6IGFueSkgPT4ge1xuLy8gICAgICAgcmV0dXJuIHtcbi8vICAgICAgICAgLi4ucHJldlN0YXRlLFxuLy8gICAgICAgICBbZmlsZU5hbWVdOiBwZXJjZW50XG4vLyAgICAgICB9O1xuLy8gICAgIH0pO1xuLy8gICB9O1xuLy8gICBjb25zdCBzdGFydFVwbG9hZCA9IGFzeW5jICgpID0+IHtcbi8vICAgICBpZiAodXBsb2FkU3RhcnRDYWxsYmFjaykge1xuLy8gICAgICAgdXBsb2FkU3RhcnRDYWxsYmFjayhmaWxlc1RvU3RvcmUpO1xuLy8gICAgIH1cbi8vICAgICBzZXRVcGxvYWRCdXR0b25DbGlja2VkKHRydWUpO1xuLy8gICAgIGZpbGVzVG9TdG9yZS5mb3JFYWNoKGZpbGUgPT4ge1xuLy8gICAgICAgY29uc3Qgc3RvcmFnZVJlZiA9IGZiUmVmKHN0b3JhZ2UsIGAke3N0b3JhZ2VGb2xkZXJ9LyR7ZmlsZS5uYW1lfWApO1xuLy8gICAgICAgY29uc3QgdXBsb2FkVGFzayA9IHVwbG9hZEJ5dGVzUmVzdW1hYmxlKHN0b3JhZ2VSZWYsIGZpbGUpO1xuLy8gICAgICAgdXBsb2FkVGFzay5vbihcbi8vICAgICAgICAgXCJzdGF0ZV9jaGFuZ2VkXCIsXG4vLyAgICAgICAgIHNuYXBzaG90ID0+IHtcbi8vICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgucm91bmQoXG4vLyAgICAgICAgICAgICAoc25hcHNob3QuYnl0ZXNUcmFuc2ZlcnJlZCAvIHNuYXBzaG90LnRvdGFsQnl0ZXMpICogMTAwXG4vLyAgICAgICAgICAgKTtcbi8vICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHNuYXBzaG90LnJlZi5uYW1lO1xuLy8gICAgICAgICAgIGhhbmRsZVByb2dyZXNzKHByb2dyZXNzLCBmaWxlTmFtZSk7XG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIGVycm9yID0+IHtcbi8vICAgICAgICAgICBhbGVydChlcnJvcik7XG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIGFzeW5jICgpID0+IHtcbi8vICAgICAgICAgICBjb25zdCBkb3dubG9hZFVybCA9IGF3YWl0IGdldERvd25sb2FkVVJMKHVwbG9hZFRhc2suc25hcHNob3QucmVmKTtcbi8vICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHVwbG9hZFRhc2s/LnNuYXBzaG90Py5yZWY/Lm5hbWU7XG4vLyAgICAgICAgICAgaGFuZGxlVXBsb2FkU3VjY2VzcyhmaWxlTmFtZSwgZG93bmxvYWRVcmwpO1xuLy8gICAgICAgICB9XG4vLyAgICAgICApO1xuLy8gICAgIH0pO1xuLy8gICB9O1xuLy8gICBjb25zdCBoYW5kbGVVcGxvYWRTdWNjZXNzID0gYXN5bmMgKGZpbGVOYW1lOiBzdHJpbmcsIGRvd25sb2FkVXJsOiBzdHJpbmcpID0+IHtcbi8vICAgICBzZXRGaWxlc1RvU3RvcmUocHJldlN0YXRlID0+IHtcbi8vICAgICAgIGNvbnN0IGN1cnJlbnRGaWxlSW5kZXggPSBwcmV2U3RhdGUuZmluZEluZGV4KFxuLy8gICAgICAgICBtZW1iZXIgPT4gbWVtYmVyLm5hbWUgPT09IGZpbGVOYW1lXG4vLyAgICAgICApO1xuLy8gICAgICAgY29uc3QgbmV3RmlsZUluZm8gPSBPYmplY3QuYXNzaWduKHByZXZTdGF0ZVtjdXJyZW50RmlsZUluZGV4XSk7XG4vLyAgICAgICBuZXdGaWxlSW5mby5kb3dubG9hZFVybCA9IGRvd25sb2FkVXJsO1xuLy8gICAgICAgY29uc3QgbmV3U3RhdGUgPSBbXG4vLyAgICAgICAgIC4uLnByZXZTdGF0ZS5zbGljZSgwLCBjdXJyZW50RmlsZUluZGV4KSxcbi8vICAgICAgICAgbmV3RmlsZUluZm8sXG4vLyAgICAgICAgIC4uLnByZXZTdGF0ZS5zbGljZShjdXJyZW50RmlsZUluZGV4ICsgMSlcbi8vICAgICAgIF07XG4vLyAgICAgICBpZiAodXBsb2FkQ29tcGxldGVDYWxsYmFjaykge1xuLy8gICAgICAgICBjb25zdCBmaWxlc1dpdGhEb3dubG9hZFVybHMgPSBuZXdTdGF0ZS5maWx0ZXIoXG4vLyAgICAgICAgICAgbWVtYmVyID0+IG1lbWJlci5kb3dubG9hZFVybFxuLy8gICAgICAgICApO1xuLy8gICAgICAgICBpZiAobmV3U3RhdGUubGVuZ3RoID09PSBmaWxlc1dpdGhEb3dubG9hZFVybHMubGVuZ3RoKSB7XG4vLyAgICAgICAgICAgdXBsb2FkQ29tcGxldGVDYWxsYmFjayh7ZmlsZXM6IG5ld1N0YXRlfSk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbi8vICAgICB9KTtcbi8vICAgfTtcbi8vICAgLy8gZXZlbnQgcHJvcCBkZWZpbmVkIGFzIGFueSBiZWNhdXNlIGl0IG1pZ2h0IGJlIGFuIEBtdWkgY2hlY2tib3ggb3IgYW55IG90aGVyXG4vLyAgIC8vIGtpbmQgb2YgY2hlY2tib3gsIG5vdCBqdXN0IGFuIEhUTUwgb25lLlxuLy8gICBjb25zdCBoYW5kbGVGaWxlUmVtb3ZhbENoZWNrID0gKGV2ZW50OiBhbnkpID0+IHtcbi8vICAgICBpZiAoZXZlbnQudGFyZ2V0LmNoZWNrZWQpIHtcbi8vICAgICAgIHNldEZpbGVzVG9SZW1vdmUoWy4uLmZpbGVzVG9SZW1vdmUsIGV2ZW50Py50YXJnZXQ/LnZhbHVlXSk7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIHNldEZpbGVzVG9SZW1vdmUoXG4vLyAgICAgICAgIGZpbGVzVG9SZW1vdmUuZmlsdGVyKG1lbWJlciA9PiBtZW1iZXIgIT09IGV2ZW50LnRhcmdldC52YWx1ZSlcbi8vICAgICAgICk7XG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICBjb25zdCBoYW5kbGVSZW1vdmVGaWxlcyA9ICgpID0+IHtcbi8vICAgICBzZXRGaWxlc1RvU3RvcmUoXG4vLyAgICAgICBmaWxlc1RvU3RvcmUuZmlsdGVyKG1lbWJlciA9PiAhZmlsZXNUb1JlbW92ZS5pbmNsdWRlcyhtZW1iZXIubmFtZSkpXG4vLyAgICAgKTtcbi8vICAgICBzZXRGaWxlc1RvUmVtb3ZlKFtdKTsgLy8gSW1wb3J0YW50IHRvIGNsZWFyIHRoaXMgYWZ0ZXJcbi8vICAgfTtcbi8vICAgY29uc3QgaW1nUHJldmlld1N0eWxlcyA9IHtcbi8vICAgICAuLi5zdHlsZXMuaW1hZ2VQcmV2aWV3LFxuLy8gICAgIC4uLm9wdGlvbnM/LnN0eWxlcz8uaW1nUHJldmlld1xuLy8gICB9O1xuLy8gICBjb25zdCBpbWdQcmV2aWV3VGl0bGVTdHlsZXMgPSB7XG4vLyAgICAgLi4uc3R5bGVzLmltYWdlUHJldmlld1RpdGxlLFxuLy8gICAgIC4uLm9wdGlvbnM/LnN0eWxlcz8uaW1nUHJldmlld1RpdGxlXG4vLyAgIH07XG4vLyAgIHJldHVybiAoXG4vLyAgICAgPD5cbi8vICAgICAgIDxJbWFnZURyb3Agb25Ecm9wPXtoYW5kbGVJbWFnZUNoYW5nZX0gbXVsdGlwbGU9e211bHRpcGxlfSAvPlxuLy8gICAgICAgPGRpdlxuLy8gICAgICAgICBzdHlsZT17e1xuLy8gICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuLy8gICAgICAgICAgIGZsZXhXcmFwOiBcIndyYXBcIlxuLy8gICAgICAgICB9fT5cbi8vICAgICAgICAge2ZpbGVzVG9TdG9yZS5sZW5ndGggPiAwXG4vLyAgICAgICAgICAgPyBmaWxlc1RvU3RvcmUubWFwKGZpbGUgPT4gKFxuLy8gICAgICAgICAgICAgICA8ZGl2XG4vLyAgICAgICAgICAgICAgICAga2V5PXtmaWxlLm5hbWV9XG4vLyAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbi8vICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuLy8gICAgICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbi8vICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIixcbi8vICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogMTAsXG4vLyAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogMTBcbi8vICAgICAgICAgICAgICAgICB9fT5cbi8vICAgICAgICAgICAgICAgICA8aW1nXG4vLyAgICAgICAgICAgICAgICAgICBzcmM9e2ZpbGUucHJldmlld31cbi8vICAgICAgICAgICAgICAgICAgIHRpdGxlPXtmaWxlLm5hbWV9XG4vLyAgICAgICAgICAgICAgICAgICBhbHQ9e2ZpbGUubmFtZX1cbi8vICAgICAgICAgICAgICAgICAgIHN0eWxlPXtpbWdQcmV2aWV3U3R5bGVzfVxuLy8gICAgICAgICAgICAgICAgIC8+XG4vLyAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17aW1nUHJldmlld1RpdGxlU3R5bGVzfT5cbi8vICAgICAgICAgICAgICAgICAgIDxsYWJlbFxuLy8gICAgICAgICAgICAgICAgICAgICBodG1sRm9yPXtmaWxlLm5hbWV9XG4vLyAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXtvcHRpb25zPy5zdHlsZXM/LmltZ1ByZXZpZXdMYWJlbH0+XG4vLyAgICAgICAgICAgICAgICAgICAgIHtgJHtmaWxlLm5hbWV9ICgke3ByZXR0eUJ5dGVzKGZpbGUuc2l6ZSl9KWB9XG4vLyAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuLy8gICAgICAgICAgICAgICAgICAgPENoZWNrYm94Q29udHJvbFxuLy8gICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtmaWxlc1RvUmVtb3ZlLmluY2x1ZGVzKGZpbGUubmFtZSl9XG4vLyAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVGaWxlUmVtb3ZhbENoZWNrfVxuLy8gICAgICAgICAgICAgICAgICAgICBpZD17ZmlsZS5uYW1lfVxuLy8gICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmlsZS5uYW1lfVxuLy8gICAgICAgICAgICAgICAgICAgLz5cbi8vICAgICAgICAgICAgICAgICA8L2Rpdj5cbi8vICAgICAgICAgICAgICAgPC9kaXY+XG4vLyAgICAgICAgICAgICApKVxuLy8gICAgICAgICAgIDogbnVsbH1cbi8vICAgICAgIDwvZGl2PlxuLy8gICAgICAgPGRpdiBzdHlsZT17e2Rpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwifX0+XG4vLyAgICAgICAgIDxCdXR0b25Db250cm9sXG4vLyAgICAgICAgICAgdmFyaWFudD1cImNvbnRhaW5lZFwiXG4vLyAgICAgICAgICAgb25DbGljaz17aGFuZGxlUmVtb3ZlRmlsZXN9XG4vLyAgICAgICAgICAgc3R5bGU9e3t0ZXh0VHJhbnNmb3JtOiBcIm5vbmVcIiwgbWFyZ2luVG9wOiAxMCwgbWFyZ2luUmlnaHQ6IDEwfX1cbi8vICAgICAgICAgICBkaXNhYmxlZD17ZmlsZXNUb1JlbW92ZS5sZW5ndGggPT09IDB9PlxuLy8gICAgICAgICAgIHsvKiA8RGVsZXRlSWNvbiBzdHlsZT17eyBtYXJnaW5SaWdodDogMTAgfX0gLz4gKi99XG4vLyAgICAgICAgICAge3JlbW92ZUJ1dHRvbkljb24gPyAoXG4vLyAgICAgICAgICAgICA8UmVtb3ZlQnV0dG9uSWNvbiBzdHlsZT17e21hcmdpblJpZ2h0OiAxMH19IC8+XG4vLyAgICAgICAgICAgKSA6IG51bGx9XG4vLyAgICAgICAgICAgUmVtb3ZlIGNoZWNrZWQgZmlsZXNcbi8vICAgICAgICAgPC9CdXR0b25Db250cm9sPlxuLy8gICAgICAgICA8QnV0dG9uQ29udHJvbFxuLy8gICAgICAgICAgIGNvbG9yPVwicHJpbWFyeVwiXG4vLyAgICAgICAgICAgdmFyaWFudD1cImNvbnRhaW5lZFwiXG4vLyAgICAgICAgICAgb25DbGljaz17c3RhcnRVcGxvYWR9XG4vLyAgICAgICAgICAgc3R5bGU9e3t0ZXh0VHJhbnNmb3JtOiBcIm5vbmVcIiwgbWFyZ2luVG9wOiAxMCwgbWFyZ2luUmlnaHQ6IDEwfX1cbi8vICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWQgfHwgZmlsZXNUb1N0b3JlLmxlbmd0aCA9PT0gMH0+XG4vLyAgICAgICAgICAgey8qIDxDbG91ZFVwbG9hZEljb24gc3R5bGU9e3sgbWFyZ2luUmlnaHQ6IDEwIH19IC8+ICovfVxuLy8gICAgICAgICAgIHt1cGxvYWRCdXR0b25JY29uID8gKFxuLy8gICAgICAgICAgICAgPFVwbG9hZEJ1dHRvbkljb24gc3R5bGU9e3ttYXJnaW5SaWdodDogMTB9fSAvPlxuLy8gICAgICAgICAgICkgOiBudWxsfVxuLy8gICAgICAgICAgIHtmaWxlc1RvU3RvcmUubGVuZ3RoID4gMSA/IFwiVXBsb2FkIGFsbFwiIDogXCJVcGxvYWRcIn1cbi8vICAgICAgICAgPC9CdXR0b25Db250cm9sPlxuLy8gICAgICAgPC9kaXY+XG4vLyAgICAgICA8ZGl2IHN0eWxlPXt7ZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsIG1hcmdpblRvcDogMTB9fT5cbi8vICAgICAgICAgey8qIHt1cGxvYWRCdXR0b25DbGlja2VkICYmICggKi99XG4vLyAgICAgICAgIHt1cGxvYWRCdXR0b25DbGlja2VkICYmXG4vLyAgICAgICAgICAgZmlsZXNUb1N0b3JlLm1hcChmaWxlID0+IHtcbi8vICAgICAgICAgICAgIHJldHVybiAoXG4vLyAgICAgICAgICAgICAgIDxQcm9ncmVzc0NvbnRyb2xcbi8vICAgICAgICAgICAgICAgICB2YWx1ZT17dXBsb2FkU3RhdGVbZmlsZS5uYW1lXSB8fCAwfVxuLy8gICAgICAgICAgICAgICAgIGtleT17ZmlsZS5uYW1lfVxuLy8gICAgICAgICAgICAgICAgIGNvbXBvbmVudD17cHJvZ3Jlc3NDb250cm9sfVxuLy8gICAgICAgICAgICAgICAgIGNvbXBvbmVudFdyYXBwZXJTdHlsZXM9e29wdGlvbnM/LnN0eWxlcz8ucHJvZ3Jlc3NDb250cm9sV3JhcHBlcn1cbi8vICAgICAgICAgICAgICAgICBmaWxlTmFtZT17ZmlsZS5uYW1lfVxuLy8gICAgICAgICAgICAgICAvPlxuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICB9KX1cbi8vICAgICAgIDwvZGl2PlxuLy8gICAgIDwvPlxuLy8gICApO1xuLy8gfTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZpcmViYXNlVXBsb2FkSW1hZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/FirebaseUploader.tsx\n");

/***/ }),

/***/ "./src/index.tsx":
/*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nconst FirebaseUploader_1 = __importDefault(__webpack_require__(/*! ./FirebaseUploader */ \"./src/FirebaseUploader.tsx\"));\nconst App = (props) => (react_1.default.createElement(FirebaseUploader_1.default, Object.assign({}, props)));\nexports[\"default\"] = App;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHN4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLG1CQUFPLENBQUMsb0JBQU87QUFDL0MsMkNBQTJDLG1CQUFPLENBQUMsc0RBQW9CO0FBQ3ZFLGtHQUFrRztBQUNsRyxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3JmaXUvLi9zcmMvaW5kZXgudHN4P2VjMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBGaXJlYmFzZVVwbG9hZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vRmlyZWJhc2VVcGxvYWRlclwiKSk7XG5jb25zdCBBcHAgPSAocHJvcHMpID0+IChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChGaXJlYmFzZVVwbG9hZGVyXzEuZGVmYXVsdCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBcHA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.tsx\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.tsx");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});